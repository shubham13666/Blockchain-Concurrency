# Blockchain-Concurrency
 A blockchain is the structure of data that represents a financial ledger entry, or a record of a transaction. Each transaction is digitally signed to ensure its authenticity and that no one tampers with it, so the ledger itself and the existing transactions within it are assumed to be of high integrity. By allowing digital information to be distributed but not copied, blockchain technology created the backbone of a new type of internet. Originally devised for the digital currency, Bitcoin, the tech community is now finding other potential uses for the technology. The most remarkable thing about the blockchain technology is its security, since the data is stored in several computers, which would make it impossible to modify all the backup copies of the network to its own benefit. The blocks are ordered in chronological order and each has a hash (numerical password) from the previous block, which makes it impossible for a block with a failed hash to be introduced in the chain and replicated by the nods or other computers in the network.

* Initially Blockchain (like Bitcoin) focused only on digital transactions, leaving its complete potential unutilized. Ethereum introduced smart contracts and a way to perform actions by the rules defined in the contract.Smart contracts are being touted as something that one day could replace lawyers. The idea is to use computerized contracts which are stored within the blockchain and which can be automatically activated if certain conditions are met.Smart contracts can be stored securely and accessed by all parties through a decentralized system. Any attempts to change the contract could be rejected and all stakeholders will be automatically informed.
* Existing smart contract designs limit throughput because they admit no concurrency. In case of permissionless blockchain (like ethereum) the miner executes the transactions serially and form the blocks. A miner cannot simply execute these contracts in parallel, because they may perform conflicting accesses to shared data. In case of permissioned blockchain (like HyperLedger) the ordering service decides the order of the transactions and form the blocks. The committing peers on receiving the blocks for validation have no option other than to execute the transactions serially as ordered by the ordering service. When a miner creates a block, it groups a sequence of transactions, and executes those transactions’ smart contracts serially to arrive at a new state, in the order they occur in the block. A miner cannot simply execute these contracts in parallel, because they may perform conflicting accesses to shared data, and it could produce an inconsistent final state. For smart contracts, it is impossible to tell in advance whether two contract executions will conflict, because the contract language, essentially in this case solidity,  is Turing Complete.
* A transaction is executed in two contexts: once by miners before attempting to append a block to the blockchain, and many times afterward by validators checking that each block in the blockchain is honest. In both contexts, each block’s transactions are executed sequentially in block order. So, to increase the throughput, it is required that the transactions are executed parallelly by validators also.
* Existing design of hyperledger fabric design restricts parallel execution of the chaincodes in the channel. The transactions proposed by the clients after completing the endorsement phase are broadcasted to the ordering service which orders the transactions and forms the block. The blocks are then sent to the committing peers. The committing peers have no option other than to serially execute the transactions of the block. The absence of parallelism decreases the throughput.
## Ethereum-
* Miners are rewarded for each block they successfully append to the blockchain, so they have a strong motive to increase the throughput by parallelizing smart contract executions. So, we are focussing on adding concurrency in smart contracts so that when a miner node executes the transactions, it does so in a parallelized manner and increase the throughput. But a miner cannot simply execute these contracts in parallel, because they may perform conflicting accesses to shared data, and it could produce an inconsistent final state.
* We experimented with a simple smart contract called ‘Ballot’ (written in Solidity)which is provided in the documentation itself. Concurrent execution of the smart contract functions are carried out in C++11 on Linux environment using pthreads. The smart contract functions (transactions) are assigned to threads. Depending upon the number of threads supported by a system’s hardware, those many threads are deployed and the transaction calls (in this case, voters) are divided equally among them. Mutex locks are used to ensure thread safety and prevent conflicts.
* Another possible method which is proposed by Thomas Dickerson (Brown University) in his paper  “Adding Concurrency to Smart Contracts”, in which he proposed the miners to execute contract codes in parallel by adapting techniques from Software Transactional Memory (STM), treating each execution call as a ‘speculative atomic action’. Data conflicts, detected at run-time, are resolved by delaying or rolling back some conflicting execution calls. This creates a serializable concurrent schedule, producing the same final state as it would have been in case of a serial schedule where the contract functions are executed in one-at-a-time order.
* After a block has been successfully appended to the blockchain, that block’s transactions are sequentially re-executed by every node in the network to check that the block’s state transition was computed honestly and correctly. (Smart contract transactions are deterministic, so each re-execution yields the same results as the original.) These validator nodes do not receive fees for re-execution. So, to get a final valid state, we need the validators to run the transactions in the same order as executed by the miner. If a miner executes these transactions in a parallelized manner, the miner needs to record these transactions and in a way send it to the validators so that the validators execute the transactions in the same  sequence in order to arrive at the same final state as the miner.

## Challenges-
* Solidity, the language used to write the smart contracts, doesn’t support multi-threading.   Even if we try to change the compiler to add multi-threading, EVM (Ethereum Virtual Machine) won’t understand the new byte code produced as EVM doesn’t has the instruction set required to execute multi-threading.
